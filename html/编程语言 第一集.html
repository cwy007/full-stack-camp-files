
<style>
  .frame {
      margin-left: 30px;
      margin-right: 30px;
  }

  h1, h2, h3, h4, h5, h6 {
      font-weight: normal;
  }

  .view-count {
      float: right;
      margin-top: -54px;
      color: #9B9B9B;
  }

  .markdown h2, .markdown h3, .markdown h4 {
      text-align: left;
      font-weight: 800;
      font-size: 16px !important;
      line-height: 100%;
      margin: 0;
      color: #555;
      margin-top: 16px;
      margin-bottom: 16px;
      border-bottom: 1px solid #eee;
      padding-bottom: 5px;
  }

    .markdown .figure-code figcaption {
      background-color: #e6e6e6;

      font: 100%/2.25 Monaco, Menlo, Consolas, 'Courier New', monospace;
      text-indent: 10.5px;

      -moz-border-radius: 0.25em 0.25em 0 0;
      -webkit-border-radius: 0.25em;
      border-radius: 0.25em 0.25em 0 0;
      -moz-box-shadow: inset 0 0 0 1px #d9d9d9;
      -webkit-box-shadow: inset 0 0 0 1px #d9d9d9;
      box-shadow: inset 0 0 0 1px #d9d9d9;
  }

  .markdown {
      position: relative;
      line-height: 1.8em;
      font-size: 14px;
      text-overflow: ellipsis;
      word-wrap: break-word;
      font-family: 'PT Serif', Georgia, Times, 'Times New Roman', serif !important;
  }

  .markdown ol li, .markdown ul li {
      line-height: 1.6em;
      padding: 2px 0;
      color: #333;
      font-size: 16px;
  }

  .markdown .figure-code {
      margin: 20px 0;
  }

  .post-content {
      padding-top: 5px;
      padding-bottom: 5px;
  }

  .markdown code {
      background-color: #ececec;
      color: #d14;
      font-size: 85%;
      text-shadow: 0 1px 0 rgba(255,255,255,0.9);
      border: 1px solid #d9d9d9;
      padding: 0.15em 0.3em;
  }

  div {
      display: block;
  }

  .markdown figure.code pre {
      background-color: #ffffcc !important;
  }

  .code .gi {
      color: #859900;
      line-height: 1.2em;
  }

  .code .err {
      color: #93A1A1;
  }

  .markdown a:link, .markdown a:visited {
      color: #0069D6 !important;
      text-decoration: none !important;
  }

  .markdown p {
      font-size: 16px;
      line-height: 1.5em;
  }

  .markdown blockquote {
      margin-left: 0 !important;
      margin-right: 0 !important;
      padding: 12px;
      border-left: 5px solid #50AF51;
      background-color: #F3F8F3;
      clear: both;
      display: block;
  }

  .markdown blockquote>*:first-child {
      margin-top: 0 !important;
  }

  .markdown blockquote>*:last-child {
      margin-bottom: 0 !important;
  }

  .markdown blockquote p {
      color: #222;
  }

  * {
      outline: none !important;
  }

  a:active, a:hover, a:link, a:visited {
      text-decoration: none;
  }

  pre {
      margin: 0;
  }

  .markdown img {
      vertical-align: top;
      max-width:100%;
      height:auto;
  }

  h1 a {
    color: #071A52;
  }

  h4 {
    color: #734488;
  }

  hr {
    border-color: #DEDEDE;
    border-width: 0.8px;
    margin-bottom: auto;
  }

  .end {
    height: 400px;
  }

  .end img {
    clear: both;
    display: block;
    margin: 10px auto;
  }

  .end p {
    text-align: center;
    font-size: 2.5em;
    margin: 60px auto 100px;
    color: #ddd;
  }
</style>
<div class='frame'><h1>
      1. 前言
    </h1><h4>所属章节：程序是如何运作的？</h4><hr><div class="post group">
    <div class="post-content markdown">
      <p>这堂课将介绍各种关于编程语言的知识理论，并用各位熟悉的 Ruby 语言来举例。</p>

<p>要学会开车，不需要知道汽车内部构造原理，但是如果要当职业赛车手，就需要了解汽车内部各个元件的作用了，了解这些零件是如何整合在一起的。这样才可以用得更好，避免误用。万一半途抛锚了，也能很快做故障排除，知道哪个零件坏了会有什么影响，可不可以继续开，如果要修又要多少时间和成本。不过，你仍然不需要知道太底层的东西，例如怎么真的去制作内燃机、轮胎等零件。</p>

<p>在完成这堂课之后，你可以回答以下问题:</p>

<ul>
<li>程序在计算机中是如何执行的?</li>
<li>Ruby 编程语言和其他程式语言有什么不同?</li>
<li>计算机的架构是什么？内存是干嘛的？</li>
<li>操作系统是干嘛的?</li>
<li>各种数据型态的差异</li>
<li>为什么有乱码? 什么是 Unicode 万国码?</li>
<li>什么是正规表示法 Regular Expression，这可以干嘛？</li>
<li>什么是算法、数据结构？</li>
<li>如何用 BigO 评估算法效能，了解不同数据结构的效能差异</li>
</ul>

    </div>
  </div></div><div class='frame'><h1>
      2. 什么是编程语言
    </h1><h4>所属章节：程序是如何运作的？</h4><hr><div class="post group">
    <div class="post-content markdown">
      <p>编程语言用来描述电脑如何工作，电脑很厉害可以处理超多资料、每秒可以做数亿次的操作(operations)，但是同时也很笨，每个操作很简单机械、没有见解或理解。编程语言也需要很精确，需要固定语法(syntax)结构让电脑可以了解。</p>

<p>世界上很有很多编程语言，为什么有这么多种语言呢？让我们先分成两种：低级语言和高级语言来说明。</p>
<h4>低级语言</h4>
<p>低级语言指的是<a href="https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80">机器语言</a>和<a href="https://zh.wikipedia.org/wiki/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80">汇编语言</a>，一步一步指示电脑微处理器如何动作，是最原始的编程语言。低级语言不是说比高级语言差，而是指抽象化的程度比较低，与电脑硬件的指令直接对应的意思。</p>

<p>首先，一台电脑的组成，包括中央处理器(CPU)、内存(RAM)、硬盘和其他 I/O 设备(网卡、键盘、鼠标和萤幕等)。其中内存就像是短期记忆，所有正要执行的指令和数据，都会先放在内存上。CPU 会从内存读取出要执行的指令和数据，执行完的结果再放回内存。内存的速度很快，但是只要关机重开，数据就会不见，而且容量较小。为了持久化数据，我们用硬盘来存成档案，来做持续保存。硬盘的空间很大，也比较便宜。</p>

<p>中央处理器(CPU)有自己的指令集，不同厂商的 CPU 指令集不一样，例如 <a href="https://zh.wikipedia.org/wiki/X86">Intel x86</a> 和 <a href="https://zh.wikipedia.org/wiki/ARM%E6%9E%B6%E6%9E%84">ARM</a> 不一样。Intel 的 CPU 主宰了桌机和服务器市场，特色是效能高跑得快。而 ARM 架构的 CPU 特色是省电，因此大部分的手机和行动装置，都是用 ARM 架构的 CPU。</p>

<p>机器语言会指示 CPU 进行什么操作：首先将指令和数据从内存搬进 CPU 的寄存器，接着 CPU 进行计算，然后将结果从CPU 寄存器搬回内存，代码长得像这样：</p>

<figure class="figure-code code"><div class="highlight"><pre>000000 00001 00010 00110 00000 100000
100011 00011 01000 00000 00001 000100
000010 00000 00000 00000 10000 000000
</pre></div>
</figure>

<p>看不懂意义是正常的。其中每一行内容就是某个 CPU 指令、CPU 寄存器编号，以及内存位址。这个内存位址的长度是固定的，目前主流是 32 位元或 64 位元 (所以 CPU 跟操作系统，还有分 64 位元和 32 位元，指的就是这个长度)。</p>

<blockquote>
<p>电脑的数字信号是以二进制数来表示的，一个 0 或 1 就是一个位元(bits)。8个 bits 称为 1 bytes 是常见电脑计算容量的基本单位，32位元也就是4bytes的长度。在往上则是 1000 byte 或 1024 bytes 为 1 kilobyte (1KB)。1000 或 1024 KB 是 1 Megabyte (1 MB)、1000 或 1024 MB 是 1 Gibibyte、1000 或 1000 GiB 是 1 Tebibyte (1TB)。什么时候用十进制 1000 什么时候用二进制的 1024 (二的十次方)呢？对商人有利的时候就会用十进制，例如卖你硬盘容量的时候讲 1T，但是硬盘格式化之后，电脑是用二进制运作的，所以变成 930 GB 而已。</p>
</blockquote>

<p>机器语言人类是很难直接阅读和撰写，因此 CPU 厂商发明了汇编语言，基本上就是对应机器语言，只是给予符号意义，长得像这样：</p>

<figure class="figure-code code"><div class="highlight"><pre>MOV eax, 1
ADD eax, 4
SUB eax, 2
MOV num, eax
INVOKE printf, ADDR formatStr, num
ret    0
</pre></div>
</figure>

<p>低级语言写起来很费事，但电脑跑起来飞快。注意，不同 CPU 的机器码(又叫做 native code)是不一样的。因此 Intel x86 和 ARM CPU 的代码、32位元和64位元的程序是不通用的。</p>

<blockquote>
<p>这世界上 10 种人，懂二进制的，以及不懂二进制的。</p>
</blockquote>
<h4>高级语言</h4>
<p>由于撰写低级语言的开发速度太慢，因此我们会用所谓的高级语言来开发软件。高级语言透过结构化的程序设计语法，包括变量、数据型态 函式、控制结构、循环等等功能，来让开发好读好写。</p>

<p>这些高级语言例如 C 语言、Java 语言、PHP/Python/Ruby 等等。其中最重要的发明就是 C 语言了，长得像这样：</p>

<figure class="figure-code code"><div class="highlight"><pre>#include &lt;stdio.h&gt;
int main() {
    int n, i, sum = 0;

    printf("Enter a positive integer: ");
    scanf("%d",&amp;n);

    for(i=1; i &lt;= n; ++i) {
        sum += i;   // sum = sum+i;
    }

    printf("Sum = %d",sum);
    return 0;
}

</pre></div>
</figure>

<p>请存成 <code>sum.c</code>，然后执行 <code>cc sum.c -o sum</code> 就会编译出 <code>sum</code> 这个执行档，用 <code>./sum</code> 就会执行。这个程式会从 1 累加到你输入的一个数字。</p>

<p>在 C 语言中，使用变量需要先宣告数据型态，例如这里是 <code>int</code> 表示整数。它会预先跟内存要固定的空间(int 会要 4 bytes)。在 C 语言中，要使用变量都必须跟内存先讲要多少空间。</p>

<p>电脑可以执行机器码，但是无法直接消化高级语言，这些高级语言的源代码都必须经过一个编译(compile)的过程，转换成二进制机器语言，也就是可执行的档案。</p>

<p>这个编译的工具，叫做编译器(Compiler)。你不必弄明白代码是怎么变成二进制码的机器语言，但你得知道这个过程。</p>

<p>电脑软件可以分成系统软件和应用软件，前者包括操作系统、编译器、嵌入式系统等等，不希望有任何效能损耗，需要了解硬件、操控硬件，例如内存空间。后者则是各种 App、桌面软件、手机软件、Web 应用等，效能上可以有权衡(trade-off)，好写好改 vs. 程式执行效能，来因应变来变去的商务需求。</p>

<p>其中 C 语言是最重要的系统程式语言，目前绝大部分编程语言的编译器，都是用 C 语言写的，例如 Ruby 也是用 C 语言写的。C 源码经过编译后可以移植到不同硬件上(例如 Intel 或 ARM，同一份 C 源码，用不同平台编译器编译出不同的机器码)上，执行的效能非常好。</p>

<blockquote>
<p>趣闻：<a href="https://news.cnblogs.com/n/533687/">那第一个C语言编译器是怎样编写的？</a></p>
</blockquote>

    </div>
  </div></div><div class='frame'><h1>
      3. 什么是操作系统
    </h1><h4>所属章节：程序是如何运作的？</h4><hr><div class="post group">
    <div class="post-content markdown">
      <p>关于编程语言是如何运作的，我们还漏介绍一个关键的系统软件，那就是<a href="https://zh.wikipedia.org/zh-cn/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>。</p>

<p>一台电脑不只跑一只程序，而是同时有非常多程序在执行，另外还有各式各样不同厂商的I/O设备。而操作系统就是负责管理这些硬件资源的程序，它会负责管理如何分配内存给不同的程序和优先级、控制I/O设备，例如硬盘、网卡、鼠标、键盘等等，并且提供一个用户接口让我们可以安装和操作不同应用软件。</p>

<p>因此，上一章有提到的高级语言需要透过编译器转换成机器码，会因为不同 CPU 架构而不同，也会因为不同的操作系统而不同。不同的操作系统，会提供不同的 API 让编程语言可以调用硬件资源。编程语言不需要知道不同厂商的硬盘怎么调用，编程语言内部会调用操作系统所提供的档案 API，而不同厂商的硬盘，会提供驱动(Driver)软件与操作系统串接。</p>

<p>操作系统例如微软的 Windows、Apple 的 MacOS、Linux 等等。</p>

<p>让我们动手操作一下，观察一下操作系统的运作。请打开 Mac 的 Activity Monitor</p>

<p><figure><img src="https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/nzQYF8m9Sh6Xlbgi2h7Q_1.png" title=""></figure></p>

<p>其中每只正在执行的程序，就叫做 Process 进程，会有一个编号是 PID。每个 Process 会被操作系统分配一整块内存，以及分配给一个 CPU 执行，不同 Process 可以同时执行。如果有多个 CPU 就是真的平行处理，如果只有一颗 CPU，那操作系统也会依照优先级依序让不同 Process 执行，因为 CPU 很快就好像是平行执行的一样。</p>

<p>如果一个 Process 内想要平行处理，那可以再生出轻量的 Thread(线程)，不同线程可以分配到不同 CPU 上执行，但是是共享同一块内存。撰写多线程的程序是困难的，我们不太会接触。</p>

    </div>
  </div></div><div class='frame'><h1>
      4. 内存管理
    </h1><h4>所属章节：程序是如何运作的？</h4><hr><div class="post group">
    <div class="post-content markdown">
      <p>了解内存是编程非常重要的概念，因为如果你把内存用光了，操作系统就得去把硬盘模拟成内存使用，但是由于硬盘的速度跟内存差太多了，整台电脑的效能会急剧下滑，就会呈现当机的状态。一台电脑的内存是有限的，你的 MacBook 可能只有 4G 或 8G，租一台服务器，最重要的也是先看有多少内存空间可以使用。内存越多，可以同时执行的程序就越多。</p>

<p>打开 Mac 的 Activity Monitor，点击 Memory 可以观察各个程序使用内存的情况</p>

<p><figure><img src="https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/sRR2O3OLSreyRXGqXaNS_2.png" title=""></figure></p>

<p>前几节提到在 C 语言中，使用变量需要预先跟内存索要空间，这跟 Ruby 很不一样。在 Ruby 是全自动的内存管理，你学到现在好像都不需要关心到底内存是如何被使用的吧。但是在 C 语言中需要手动管理内存。在硬件资源有限或需要效能至上的软件中，手动管理内存有其必要，但是缺点就是降低了开发效率，开发者必须注意好内存管理，用的时候要先宣告，不用的时候要释放回操作系统。如果一只程序一直消耗内存，却从来不归还给操作系统，那这只程序就是不断不断地耗用，直到全部内存都被吃光，最后电脑就当机了(或是手机上的操作系统会强制关闭你的应用)。</p>

<p>以编程语言的发展历史来看，第二重要的可能就是 Java 语言了。Java 有许多重大的发明，其中面向对象我们下一个教程会教的重点，另外就是内部 Virtual Machine(VM)跨平台设计，以及和<a href="https://zh.wikipedia.org/zh-cn/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">垃圾回收 Garbage Collection (GC)</a> 了，我们先谈谈 GC。</p>

<p>GC 是编程语言的一种内部功能，作用是自动把再没有用到的变量，把内存释出回操作系统。例如你可以想像，编程语言在执行的时候，会定时停一下检查所有变量，看看哪些变量已经没有被使用，就释放回操作系统。</p>

<p>垃圾回收可以让程式员减轻许多负担，也减少程式员犯错的机会。在 Java, Ruby, JavaScript 都有 GC，一般来说不需要特别烦恼内存的使用。还是有可能碰到内存泄露(memory leak)问题，例如不断使用内存但没有释放的机会。</p>

<p>例如以下 Ruby 程式，是一个无穷循环不断增加资料到数组里面:</p>

<figure class="figure-code code"><figcaption><span>
</span></figcaption><div class="highlight"><pre><span class="n">arr</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">i</span><span class="o">=</span><span class="mi">0</span>

<span class="k">while</span><span class="p">(</span><span class="kp">true</span><span class="p">)</span>
  <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"hahaha!"</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
<span class="k">end</span>
</pre></div>
</figure>

<p>请继续观察 Mac 的 Activity Monitor，等等你会发现有一只 Ruby 程序，它的内存用量不断上升......... (请记得中断这个程序)。</p>

<p>编程语言内部的 GC 算法非常重要，非常影响编程语言的执行效能。GC 多久执行一次，每次执行 GC 要花多少时间(一跑 GC，你的程序就等于是暂停下来)，这些都会严重影响程序的进行。例如在一些 real-time 强即时性的软件中，就说是一个机器人走路的软件好了，是不能用 GC 的，需要手动管理内存。想像一下走路腿抬到一半，然后编程语言不定就自动跑了 GC 暂停一下，那就跌倒了。</p>

<p>近十年 Ruby 1.9 到 Ruby 2.4 的版本，都着重在改进内部的 GC 算法，以来增加效能。</p>

    </div>
  </div></div><div class='frame'><h1>
      5. 编译型语言和解释型语言
    </h1><h4>所属章节：程序是如何运作的？</h4><hr><div class="post group">
    <div class="post-content markdown">
      <p>高级语言又可以分为两种：编译型语言(静态语言/Static)和解释型语言(动态语言/Dynamic)，这两种语言的优缺点，一直以来都是开发者社群最爱论战的话题。</p>

<p>编译型语言包括：C 语言、C++、Java 语言等等，这种语言要求一定要先把全部代码编译变成机器码(native code)，也就是可执行的档案。软件散布和分享的时候，是拿最后的执行档。在这类语言中，使用变量必须事先宣告类型，例如这个变量一开始宣告是 int，那就一定只能是 int，不能换成存字符串。</p>

<p>解释型语言包括: Ruby、Python、JavaScript、PHP 等等，这种语言不需要先编译，而是透过一种叫做解释器(interpreter)的软件，逐行编译然后直接执行。软件散布和分享的时候，是拿源代码。在这类语言中，使用变量不需要事先宣告类型，一开始存整数，后来换成存字符串也可以。</p>

<p>编译型语言每次修改代码，都必须重新把程序编译好，如果程序任一行有错，就无法编译。但是因为都先编译好了，所以执行的速度比较快，而且执行档很小。刚刚的 C 语言范例，编译后只有8K的大小。</p>

<p>解释型语言不需要先编译，修改起来比较方便，写代码也快一些，但是任何错误都要等到真正执行之后，才会知道。因为要等到执行时才编译，所以执行的速度较慢。一个只有一行的 Ruby 代码程序，如果要再另一台电脑跑起来，那台电脑也必须把 Ruby 解释器安装起来，而且跑起来至少需要 5MB 的内存，即使只是输出一行 Hello World。</p>

<p>所以为何有不同的程式语言呢？一方面是大家对于效率的需求不一样，有的希望是执行快，有的希望开发快。一般来说 「机器语言 -&gt; 组合语言 -&gt; C 语言 -&gt; Java 语言 -&gt; 动态语言」越往右边跑起来效能较差，但开发起来效率比较好。</p>

<p>另一方面也是编程语言的设计哲学不同，有些喜欢功能多、程式码比较有表现力，例如 Scala，但语言本身会比较复杂。有些喜欢功能少，比较精实但打比较多字，例如 Go 语言。</p>
<h4>为什么 Web 应用，使用解释型语言有更好的的优势?</h4>
<p>著名的”人月神话”一书作者Fred Brooks曾说：「一个程式设计师一天能产生的程式码行数是差不多的，无论什么程式语言」。因此一个具有表达能力的高阶程式语言，就会比低阶的程式语言能完成更多功能。相较于静态程式语言，使用更高阶的动态脚本语言可以帮助我们：</p>

<ol>
<li>用更少程式码做更多事情，大大增加生产力</li>
<li>更快因应客户开发需求，敏捷开发</li>
</ol>

<p>不过，动态语言也不是没有缺点：</p>

<ol>
<li>执行效能是绝对比不上静态语言的</li>
<li>没有编译期可以检查型别错误</li>
</ol>

<p>但是，我们知道现在的电脑越来越快、越来越便宜、上网越来越容易、内存越来越多、硬盘越来越大。另外，行动装置也越来越多，需要搭配的网络服务需求也增加了。这些趋势告诉我们有更多的软件的需求，另一方面由于硬件效能的增强，人力开发成本比起软件的执行期的效能，也越来越重要。同样一个程式，用动态语言执行的效能已经可以达到实用(例如每秒可以处理50~500个的HTTP请求，也可以透过增加服务器来扩展架构)，也许用静态语言后的执行速度可以再快一倍，但是却需要十倍以上的时间来开发，这件事情是不是值得呢？</p>

<p>在硬件资源有限的行动装置及嵌入式系统上，仍是静态语言的天下，这一点需要更多时间才有动态语言的生存空间。<br>
没有编译期可以检查型别错误的问题，也随着单元测试和TDD(Test-driven development)测试驱动开发等敏捷最佳实务而逐渐降低重要性。而大部分的Bug会出自于商业逻辑错误，而不是型别错误上。</p>

    </div>
  </div></div><div class='frame'><h1>
      6. 各种编程语言介绍
    </h1><h4>所属章节：程序是如何运作的？</h4><hr><div class="post group">
    <div class="post-content markdown">
      <p>讨论各种编程语言的优劣，也是程序员经常笔战的热门话题。以下简单介绍一些常见的编程语言：</p>

<ul>
<li>C 语言: 开发系统程式 (System Programming)、操作系统、编译器等等工具必备语言。经过编译可以移植到不同硬件上。</li>
<li>C++ 语言: 多了一大堆功能和面向对象的超级复杂版 C 语言，大型软件如 Google Chrome, Qt, WebKit, V8, HHVM 或是效能要求高的游戏等等，用 C++ 比较多。但是 C++ 由于语法太多太复杂，被认为是最不好上手的语言之一。Linux 和 Git 的发明人 Linus，就坚决反对 C++。</li>
<li>Java 语言: 提供跨平台 VM、面向对象，使用 GC 内存垃圾自动回收，由于发展已久，效能也非常好，后端很多企业软件和中间件使用，在超大型网站中也十分常见，例如阿里巴巴、Twitter、Linkedin 服务端。前端方面要 Android 软件也是用 Java 语言，</li>
</ul>

<p>这里提一下什么是跨平台，这有一些歧义。Java 当年的一个理念是跨平台(Windows、Mac、Linux 等)：同一份编译好的执行档，可以在不同平台执行，不需要像 C 语言需要编译成不同执行档。为了达成这么目的，Java 发明了一种叫做<a href="https://zh.wikipedia.org/wiki/Java%E5%AD%97%E8%8A%82%E7%A0%81">字节码(bytecode)</a>的设计，Java 会先编译成这种与平台没有依赖的字节码，但是每个平台需要先装 Java VM (JVM)，又叫做 <a href="https://java.com/download/">JRE(Java Runtime Environment)</a>，现在新的操作系统应该都有内建了。</p>

<p>这么说 Ruby 其实也是跨平台，因为同一份 Ruby 源码也可以跑在 Windows、Mac、Linux 上，只要 Ruby 的解释器(interpreter)能装上去就行。不过通常没这么幸运，因为很多 Ruby 库是用 C 语言写的，而不是 Ruby，因此不一定能在不同平台上顺利编译成功，因为这些 C 代码可能有依赖操作系统的，例如调用了某个只在 Linux 操作系统上才有的 C 库。因此很多需要编译的 gem 例如 <a href="https://rubygems.org/gems/nokogiri/versions">nokogiri</a> 甚至都必须针对 Windows 提供不同的 gem 版本。</p>

<p>不过说到真正的跨平台，目前的主流是 Web 应用，浏览器才是真正跨平台的软件。用户不需要预先安装 VM 也不需安装动态语言的解释器，只需要有个浏览器就可以了。</p>

<ul>
<li>Scala 语言、Clojure 语言、JRuby 语言等等：这些语言都建构上 JVM 上，透过编译变成 Java 字节码，就可以在不同平台上执行。这些语言用自己偏好的语法设计，然后搭上 Java VM 发展成熟的便车，可以调用 Java 的库。</li>
<li>C# 语言: 微软的官方语言，当年是仿 Java 所推出的编程语言。它的 .NET framework 等同于 JVM 的设计。在 .NET 上还有其他微软的编程语言 VB.NET, ASP.NET, F# 等等</li>
<li>Objective-C 和 Swift，苹果专用的编程语言，撰写 MacOS 和 iOS 应用必备</li>
<li>PHP 语言，当年发明的时候叫做 Personal Home Page，所以叫做 PHP。PHP 的初衷是作为 HTML 样板(就像是 Rails 里面的 html.erb)，主攻 Web  应用。因为容易上手使用，在 2000 年初搭配 MySQL 数据库非常流行。</li>
<li>Python 语言: 也是动态语言的一种，和 Ruby 时常拿来对比。近年来在数据分析和机器学习领域用得很多。</li>
<li>JavaScript 语言: 托浏览器的福，成为全世界最风行的语言。后端可以用 <a href="https://nodejs.org/en/">Node.js</a> 单独将 JavaScript 跑在服务器上，而不需要依赖浏览器的环境。</li>
<li>R 语言: 用于数据分析领域，学术领域用的很多。但不会拿来做软件应用。</li>
</ul>

<p>别人用什么?</p>

<ul>
<li>Java: Google, Oracle</li>
<li>Swift, Objective-C: Apple</li>
<li>C#: Microsoft, stack overflow</li>
<li>PHP: wikipedia, vimeo, facebook</li>
<li>Ruby: airbnb, shopify, github, twitter, groupon, basecamp, hulu+</li>
<li>Python: youtube, quora, google, instagram, pinterest</li>
</ul>

<p>编程语言有许多概念和功能是跨语言都有的，只是 ecosystem (衍生出来的套件、社群和支援)不一样，擅长的情境不一样，一般来说：</p>

<ul>
<li>开发系统程式(例如操作系统、编译器)，适合 C 语言</li>
<li>开发 Web 后端应用，适合 PHP/Ruby/Python/Node.js</li>
<li>开发 Web 前端应用，得用 JavaScript</li>
<li>开发 Android 应用，得用 Java</li>
<li>开发 iOS 应用，得用 Swift 或 Objective-C</li>
</ul>

<p>最后，「编程语言」和「编程语言的实作」是不一样的概念，前者是指语法的规格定义，后者是指编译器(或解释器)。同一门编程语言，但是有不同家的编译器(或解释器)是常见的事情，例如：</p>

<ul>
<li>JavaScript 的语法标准叫做 <a href="http://zh.wikipedia.org/wiki/ECMAScript">ECMAScript</a>，但是 JavaScript 的实作有很多，包括 Chrome 浏览器用的 <a href="https://zh.wikipedia.org/zh-cn/V8_(JavaScript%E5%BC%95%E6%93%8E)">V8 引擎</a>、Safari 用 <a href="https://zh.wikipedia.org/zh-cn/WebKit">WebKit</a>、Firefox 用 SpiderMonkey。虽然都叫 JavaScript 语言，但是真正跑在不同浏览器时，实际上是不同的解释器，还是有差异的。</li>
<li>Ruby 有 <a href="https://www.ruby-lang.org/">CRuby</a>(又叫做 MRI，大家目前安装的就是 MRI 版本)、<a href="http://jruby.org">JRuby</a>、<a href="https://rubinius.com">Rubunius</a>、
<a href="http://www.rubymotion.com">RubyMotion</a> 等等</li>
<li>PHP 有 <a href="http://php.net">Zend Engine</a> (这是官方版) 和 <a href="https://github.com/facebook/hhvm/wiki">HipHop</a> (这是 Facebook 针对 PHP 重写过的 PHP 解释器，以改进效能)</li>
<li>Objective-C 和 Swift 当然就谨此 Apple 一家出编译器</li>
<li>.NET 有微软官方版和 <a href="http://www.mono-project.com">Mono</a>
</li>
<li>Java 有 HotSpot (这是 Oracle 的官方版本) 和 OpenJDK (这是开源版本，在 Linux 安装的话会装到这个版本)</li>
</ul>

    </div>
  </div></div><div class='frame'><h1>
      7. 数据类型 Data Type: 基本数据类型
    </h1><h4>所属章节：编程语言的设计</h4><hr><div class="post group">
    <div class="post-content markdown">
      <p>在高级语言中，每个值都属于一种数据类型，这些数据类型可以概分为两种：基本数据类型和组合数据类型</p>

<p>为什么编程语言需要设计数据类型? 因为同样是 2 bytes 的资料，如果不知道是什么类型的话，那我们就无从得那 16 bits 的二进制数字代表的意义，可能是字符串、也可以是数字。</p>
<h3>Data Type 基本数据类型(Primitive Data Type)</h3>
<p>基本数据类型包括 String 字符串、Integer 整数、Float 浮点数、Boolean 布林、nil 空值等。</p>
<h3>String 字符串</h3>
<p>在编程语言内部，字符串就是一个一个字符，用数组串起来实作的。让我定义一下什么是字符：一个英文字母是一个字符、一个中文汉字是字符、一个符号也是一个字符。</p>

<p>但是电脑存储的是二进制，需要透过编码(Encoding)才能让人给这些二进制意义，透过字符集对照表，告诉我们这个二进制编码对应的字符是哪一个。</p>

<p>最早的字符集是 1967 年美国人发明的 <a href="https://zh.wikipedia.org/wiki/ASCII">ASCII</a> (American Standard Code for Information Interchange) 美国信息交换标准代码，用一个 1 byte 的空间，来储存可显示的英文字母和符号，以及不可见的控制字符，例如：</p>

<p>二进制 0100 0001，十进制 65，这个编码代表 A<br>
二进制 0100 0010，十进制 66，这个编码代表 B<br>
...<br>
二进制 0110 0001，十进制 97，这个编码代表 a<br>
...</p>

<p>不过，1 byte 的空间，至多也就是 256 种字符而已，对于非英语系国家是绝对不够用了。于是各个国家自定义了各自语言的字符集，例如：</p>

<ul>
<li>
<a href="https://zh.wikipedia.org/wiki/GB_18030">GB 2312</a> 信息交换用汉字编码字符集，收录了6763个简体汉字</li>
<li>
<a href="https://zh.wikipedia.org/zh-cn/%E5%A4%A7%E4%BA%94%E7%A0%81">Big5</a> 大五码，收录了13,060个繁体汉字，在台湾、香港与澳门使用</li>
<li>
<a href="https://zh.wikipedia.org/wiki/Shift_JIS">Shift JIS</a> 日文</li>
<li>...族繁不及备载</li>
</ul>

<p>这些语言的字符集，使用了 2 bytes 的空间，至多可以容纳 65526 种字符，看起来似乎是足够的。</p>

<p>不过，相信大家可能都碰过<a href="https://zh.wikipedia.org/zh-cn/%E4%B9%B1%E7%A0%81">乱码</a>问题，打开一份文件或是网页，发现都是无意义的字符，这就是因为使用了错误的字符集去显示，解决办法就是重新选过 Text Encoding 挑到正确的字符集，文字才能正确显示。</p>

<p>另外，如果想要同一份文件同时显示汉字、日文、韩文、越南文等等，就没有一种字符集可以满足需求耶？</p>

<p>所幸，我们目前使用的业界标准，是 1991 年开始发展的 <a href="https://zh.wikipedia.org/wiki/Unicode#.E5.8E.86.E5.8F.B2">Unicode 万国码</a>，这个计划定义了全世界所有语言的编码。在这个计划下，定义了几个字符集标准：</p>

<ul>
<li>UTF-32 用 4 bytes 来存一个字符</li>
<li>UTF-16 用 2 或 4 bytes，汉字会是 4 bytes</li>
<li>UTF-8 用不定长度 1~4 bytes，一个英文字母用 1 byte 存储，一个汉字会用 3 bytes 存储</li>
</ul>

<p>其中 UTF-32 很少使用，因为太浪费空间了。本来一个英文字母用 1 byte 就可以存，改成用 4 bytes 后，前面三个 bytes 都是 0，耗费的空间变成四倍。</p>

<p>蛮多编程语言内部是用 UTF-16 时做字符串的，例如 Java 和 Python。</p>

<p>至于 UTF-8 则是目前最为通行的标准，既能表示所有语言，空间上又比较节省。因此广泛应用在 HTML 和各种文件上。在 Rails 默认产生的网页，也都是使用 UTF-8 标准。另外，ASCII 刚好是 UTF-8 的子集，有着良好的向后相容性。</p>

<p>关于编码，可以再参考看看这篇文章 <a href="http://www.jianshu.com/p/bd7a6c508c33">字符，字符集，字符编码</a></p>

<p>Ruby 对于各种字符集的支援非常好，每个字符串，都属于一种字符集，默认是 UTF-8：</p>

<p>让我们执行 irb 实验看看：</p>

<figure class="figure-code code"><div class="highlight"><pre>"a".encoding    # 得到 &lt;Encoding:UTF-8&gt;
"a".size    # 这是 1 个字符
"a".bytesize  # 这是1个 bytes
</pre></div>
</figure>

<figure class="figure-code code"><div class="highlight"><pre>"中".encoding   # 得到 &lt;Encoding:UTF-8&gt;
"中".size      # 这是 1 个字符
"中".bytesize  # 这是3 个 bytes

</pre></div>
</figure>

<p>Ruby 内建支援了 101 种字符集。执行</p>

<figure class="figure-code code"><div class="highlight"><pre>Encoding.list.map{ |x| x.name }
 =&gt; ["ASCII-8BIT", "UTF-8", "US-ASCII", "UTF-16BE", "UTF-16LE", "UTF-32BE", "UTF-32LE", "UTF-16", "UTF-32", "UTF8-MAC", "EUC-JP", "Windows-31J", "Big5", "Big5-HKSCS", "Big5-UAO", "CP949", "Emacs-Mule", "EUC-KR", "EUC-TW", "GB2312", "GB18030", "GBK", "ISO-8859-1", "ISO-8859-2", "ISO-8859-3", "ISO-8859-4", "ISO-8859-5", "ISO-8859-6", "ISO-8859-7", "ISO-8859-8", "ISO-8859-9", "ISO-8859-10", "ISO-8859-11", "ISO-8859-13", "ISO-8859-14", "ISO-8859-15", "ISO-8859-16", "KOI8-R", "KOI8-U", "Shift_JIS", "Windows-1250", "Windows-1251", "Windows-1252", "IBM437", "IBM737", "IBM775", "CP850", "IBM852", "CP852", "IBM855", "CP855", "IBM857", "IBM860", "IBM861", "IBM862", "IBM863", "IBM864", "IBM865", "IBM866", "IBM869", "Windows-1258", "GB1988", "macCentEuro", "macCroatian", "macCyrillic", "macGreek", "macIceland", "macRoman", "macRomania", "macThai", "macTurkish", "macUkraine", "CP950", "CP951", "IBM037", "stateless-ISO-2022-JP", "eucJP-ms", "CP51932", "EUC-JIS-2004", "GB12345", "ISO-2022-JP", "ISO-2022-JP-2", "CP50220", "CP50221", "Windows-1256", "Windows-1253", "Windows-1255", "Windows-1254", "TIS-620", "Windows-874", "Windows-1257", "MacJapanese", "UTF-7", "UTF8-DoCoMo", "SJIS-DoCoMo", "UTF8-KDDI", "SJIS-KDDI", "ISO-2022-JP-KDDI", "stateless-ISO-2022-JP-KDDI", "UTF8-SoftBank", "SJIS-SoftBank"]teless-ISO-2022-JP-KDDI (autoload)&gt;, #&lt;Encoding:UTF8-SoftBank&gt;, #&lt;Encoding:SJIS-SoftBank (autoload)&gt;]
</pre></div>
</figure>

<p>你可以用 encode 转换编码到不同字符集：</p>

<figure class="figure-code code"><div class="highlight"><pre>"中".encode("GB2312")  # 得到 "\x{D6D0}" 终端机默认用 UTF-8，因此无法顺利显示 GB2312。\x 是16进制的意思
"中".encode("GB2312").bytesize # 得到 2 bytes

"中".encode("ASCII") # 这样会报错 Encoding::UndefinedConversionError: U+4E2D from UTF-8 to US-ASCII 因为汉字无法转成用 ASCII 存储
</pre></div>
</figure>

<p>以及用 force_encode 换字符集但不转换编码：</p>

<figure class="figure-code code"><div class="highlight"><pre>"\xD6\xD0".encoding # 因为默认是 UTF-8
"\xD6\xD0".force_encoding("GB2312").encode("utf-8") # 编码不变，但是告诉 Ruby 说这个是 GB2312，然后再转回 UTF-8

</pre></div>
</figure>

<p>在 Ruby 之中，默认读取写入资料都是用 UTF-8 编码，但是如果要串接其他系统或资料，就需要知道字符集的知识。例如数据库要记得用 UTF-8，抓比较旧的外部文件或网页，如果不是 UTF-8 编码的话，那就必须处理转码问题。</p>
<h3>Symbol</h3>
<p>Symbol 是 Ruby 语言特有的类型，作用跟字符串很像，但是是唯一且不会变动的识别名称，用冒号 <code>:</code> 开头，例如 <code>:this_is_a_symbol</code></p>

<p>为什么不用字符串呢？这是使用 Symbol 执行效能比较好。在 Ruby 语言内部，相同名称的 Symbol 不会再重复建构、Symbol 本身的方法也比 String 少很多、你也不能修改 Symbol。让我们进 irb 实验看看：</p>

<figure class="figure-code code"><div class="highlight"><pre>puts "foobar".object_id      # 输出 2151854740
puts "foobar".object_id      # 输出 2151830100

puts :foobar.object_id       # 输出 577768
puts :foobar.object_id       # 输出 577768
</pre></div>
</figure>

<p><code>object_id</code>方法会回传 Ruby 内部的内存位址编号。你会发现两个字符串就算内容相同，也是不同的位址。但是 Symbol 只要内容相同，就是相同位址。这种特性让 Symbol 的主要用途是作为散列 Hash 的键(Key)。</p>
<h3>Number 数值类型</h3>
<h4>整数 Integer</h4>
<p>电脑内部是用<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A1%A5%E6%95%B0">补码</a>的方式来存储整数，一个 byte 的空间可以表示 -128~127 之间的数字。在 C 语言中，需要先宣告你要使用多大的数字，例如 short 是 2 bytes，只可以存 -32768 - 32767 之间的整数，int 是 -2^31 - (2^31-1) 之间的整数。</p>

<p>在动态语言例如 Ruby 中不需要先宣告，Ruby 会自动调控使用多少 bytes 来存整数。</p>

<p>在静态语言中，需要先宣告需要用多大空间的整数，在编译的时候就会在内存中预留空间 (所以执行起来比 Ruby 快啊)。</p>
<h4>Float 浮点数</h4>
<p>如果要做科学运算、数值分析，会有很多除不尽的小数情况，这时候就会用浮点数 Float，可以表示任意长度的实数。</p>

<p>以 <a href="https://zh.wikipedia.org/zh-cn/%E5%8D%95%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0">IEEE 单精度浮点数标准</a> 为例，32位元，第一个位元是正负号、8个位元存指数，后23个位元存有效位数，透过2的指数来计算，如此就可以表示非常非常大和非常非常小的数字。</p>

<p>但是符点数有个最大的缺点就是输入与储存的值不一定精确、计算后的结果可能会有微小误差(因为无法刚好用 2 的指数来表示，只能逼近)</p>

<p><a href="http://0.30000000000000004.com/">举例</a>来说，0.1 + 0.2 是不等于 0.3 的，你可以进 irb 实验看看</p>

<figure class="figure-code code"><figcaption><span>
</span></figcaption><div class="highlight"><pre><span class="mi">0</span><span class="o">.</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="o">.</span><span class="mi">2</span>  <span class="c1"># 得到 0.30000000000000004
</span>
<span class="mi">0</span><span class="o">.</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="o">.</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">.</span><span class="mi">3</span>   <span class="c1"># 得到 false
</span></pre></div>
</figure>

<blockquote>
<p>在 JavaScript 语言中，所有数值都是浮点数。</p>
</blockquote>
<h4>Decimal 十进制数</h4>
<p>如果需要小数点，又希望绝对的精确，这时候会用 Decimal 型态，设定整数部分和小数部分的要用多少位数，可以精准表示</p>

<p>在 Ruby 内可以用 <a href="https://ruby-doc.org/stdlib-1.9.3/libdoc/bigdecimal/rdoc/BigDecimal.html">BigDecimal</a></p>

<p>不过，真正重要的其实是数据库，在 Rails migration 中，如果你要存有小数点的资料，可以用 float 或 decimal 是都可以。但是如果情境是 GPS 定位、汇率等等，已知小数长度是固定的话，这时间建议用 decimal 会比较准确。</p>

<p>例如在 Rails migration 中，最好用 deciaml 而不是 float 来存汇率或经纬度：</p>

<figure class="figure-code code"><figcaption><span>
</span></figcaption><div class="highlight"><pre><span class="c1"># 总共六位数，小位数三位
</span>
<span class="n">t</span><span class="p">.</span><span class="nf">decimal</span>  <span class="s2">"currency_rate"</span><span class="p">,</span> <span class="ss">precision: </span><span class="mi">6</span><span class="p">,</span> <span class="ss">scale: </span><span class="mi">3</span>
</pre></div>
</figure>

<p>不然可以你输入某个经度纬度，存进数据库再拿出来，可能会差小数码一些些，但对 GPS 来说可能就差好几公尺了。</p>

    </div>
  </div></div><div class='frame'><h1>
      8. 组合数据类型 (Reference Data Types)
    </h1><h4>所属章节：编程语言的设计</h4><hr><div class="post group">
    <div class="post-content markdown">
      <p>组合数据类型，包括 Array、Hash 和程序员自订的复合资料类型(也就是 Class)，这种类型的数据是一种容器，里面可以放上述的基本数据类型，或是组合其他的组合数据类型。</p>
<h3>Array 有序容器，用整数当作索引</h3>
<p>在编程基础中各位应该已经熟悉 Array 的使用，在内存里面，Array 就是用一块连续的存储空间。</p>

<figure class="figure-code code"><div class="highlight"><pre>|1|2|3|4|5|6|7|8|
</pre></div>
</figure>

<p>每个数组元素，在内存里面的大小是固定的。透过索引，我们可以很快就计算出该元素在内存中的位置。</p>

<p>例如假设每个元素占 4 bytes，<code>arr[0]</code> 在内存位置 100，那 <code>arr[3]</code> 就是 100 + 4*3 在位置 112 了。</p>
<h3>Hash Table 散列表 (或称作 Map 或 Dictionary)</h3>
<p>一种 Key-Value 的容器，通常用 Symbol 或字符串当作索引，要了解散列 Hash 的原理，需要先知道什么是散列函数。</p>

<p>散列函数是一种能将数据变成摘要(digest)的算法，执行 <code>irb</code>，然后输入以下代码实验看看：</p>

<figure class="figure-code code"><div class="highlight"><pre>require 'digest'
Digest::SHA1.hexdigest '12345678'
</pre></div>
</figure>

<p>得到 <code>"7c222fb2927d828af22f592134e8932480637c0d"</code></p>

<p>散列函数有一些很好的特性：1. 相同的数据，每次都会得到一样的摘要 2. 即使只有微小差异的内容，摘要也会差异很多，非常分散。</p>

<p>因此，我们将散列的 key 丢进这个散列函数，得到一组摘要。然后用这个摘要的前几码，来把 value 放到内存中对应的位置。</p>

<p>例如我们可以设计一个有 26*26 个空间的容器(在内存中佔用 26 * 26 * 4 bytes空间)，给予编号 aa 到 zz。然后取 key 摘要的前两码，把 value 放到那个位置：</p>

<figure class="figure-code code"><div class="highlight"><pre>|aa|ab|ac|ad|.....|zx|zy|zz|
</pre></div>
</figure>

<p>假设初始位置是 100，如果给一个 key 算出来的散列值是 ad，那我们就把值放在 100 + 4*3 在位置 112。</p>

<p>这样设计的好处是，随便给一个 key，都可以马上算出它在内存中的位置，非常有效率。</p>

<blockquote>
<p>因为只取前几码，当然有可能不同的 key 会放在同一个位置。内部实作根据这种情况，会再处理冲突，详见<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8">散列表</a>。</p>
</blockquote>
<h3>组合数据的修改</h3>
<p>辨识哪些是引用数据类型，是很重要的基本概念，例如</p>

<figure class="figure-code code"><figcaption><span>
</span></figcaption><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</figure>

<p>请问最后 b 是多少? a 是多少? 这题没坑，a 就是 2，b 就是 1。<br>
a, b 两个变量分别佔了内存的两块空间，当 <code>b = a</code> 时，b 内存就被填成当时 a 的值是 1。</p>

<p><figure><img src="https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/v4aSQqf3Tx6AYBAly9Yr_4.png" title=""></figure></p>

<p>同样的逻辑，让我们换成 array:</p>

<figure class="figure-code code"><figcaption><span>
</span></figcaption><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
<span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9</span>
</pre></div>
</figure>

<p>请问最后 a, b 数组长怎样？</p>

<p>令初学者感到意外的是，a 和 b 最后都是 <code>[9,2,3]</code>，两个数组变量都被修改到了！</p>

<p>这是因为在内存里面，组合数据类型的变量，并不是直接存它的值，而是存一个引用位址(reference)，指向另一块真正存值的内存空间。</p>

<p><figure><img src="https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/gWfO0ueSIuAzhPcxHP2e_5.png" title=""></figure></p>

<p>因此当 <code>b=a</code> 时，复制的是引用位址(reference)，指向同一块存有 <code>[1,2,3]</code> 的内存空间。当最后 <code>a[0]</code> 时，就会改到同一份数据。</p>

<p>为什么编程语言会这样设计呢？这是因为组合数据类型是个容器，这个容器可能存有非常多的数据，复制的成本是很高的。因此在默认的情况下，我们不会真的去复制它的值，而是复制引用而已。</p>
<h4>方法调用</h4>
<p>方法调用也必须注意参数是基本类型还是引用类型：</p>

<figure class="figure-code code"><figcaption><span>
</span></figcaption><div class="highlight"><pre><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">x</span> <span class="o">=</span> <span class="mi">9999</span>
  <span class="k">return</span> <span class="n">x</span>
<span class="k">end</span>

<span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">x</span>
</pre></div>
</figure>

<p>请问最后 x 是多少? 还是 1 喔。在调用 foo 的时候，这个 x 的值被复制到方法的参数 x，所以方法里面改的 x 变量，跟外面的 x 变量是不一样的。</p>

<figure class="figure-code code"><figcaption><span>
</span></figcaption><div class="highlight"><pre><span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9999</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>
<span class="n">bar</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

</pre></div>
</figure>

<p>请问最后的 arr 是多少? 也被修改成 <code>[9999,2,3]</code> 了，调用方法，被复制成为参数的是引用，所以在方法里面修改 x 就是修改 arr 的值。</p>

<p>会这样设计的原因，也是因为默认复制引用类型成本太高了。</p>
<h4>就地编辑(in-place editing)</h4>
<p>在 Ruby 内建的 API 中，有些 API 是「回传新的副本」、有些是「In-place」做修改(mutate)，例如：</p>

<p>Array 的 sort 方法：</p>

<figure class="figure-code code"><figcaption><span>
</span></figcaption><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="nf">sort</span>
</pre></div>
</figure>

<p><code>b</code> 会是排序好的 <code>[1,5,9]</code>，但是 <code>a</code> 是没有变的，还是 <code>[5,1,9]</code></p>

<p>Array 的 sort! 方法：</p>

<figure class="figure-code code"><figcaption><span>
</span></figcaption><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="n">a</span><span class="p">.</span><span class="nf">sort!</span>
</pre></div>
</figure>

<p>这个 <code>a</code> 直接被修改了，变成 <code>[1,5,9]</code></p>

<blockquote>
<p>对 Ruby 来说，这个 <code>!</code> 只是名字的一部分，没有特别的作用。只是一个惯例提醒你说这个方法会有 副作用(side-effect)。</p>
</blockquote>

<p>那什么时候要用哪一种呢？比执行速度的话，「In-place」做修改(mutate) 是比「回传新的副本」还快，因为后者需要新的内存空间来存储。不过，实际写代码时，我们一般会偏好「回传新的副本」的方式，因为这样比较不容易有 bug。</p>

<p>这是因为一个软件里面的方法会调用其他方法，其他方法里面又会调用方法，所以参数可能会传递到很深的方法里面，如果有一个方法不小心直接修改了参数，对于调用者来说，可能不是预期会被修改的行为。因此用「回传新的副本」的方式，会比较保险安全。</p>
<h4>复制</h4>
<p>组合数据类别的 <code>=</code> 指派只会复制引用，如果需要真的复制值，会改用 <code>clone</code> 方法：</p>

<figure class="figure-code code"><div class="highlight"><pre>a = [1,2,3]
b = a.clone
a[0] = 999
a
b

</pre></div>
</figure>

<p>改了 <code>a[0]</code>，就不会影响到 <code>b</code> 了。</p>

<p>不过，<code>clone</code>不是万能的，如果组合数据里面又有组合数据，那么....</p>

<figure class="figure-code code"><div class="highlight"><pre>a = [1,2,3]
b = [0, a]

c = b.clone
a[0] = 999

b
c
</pre></div>
</figure>

<p>虽然 <code>c</code> 是 clone 出来的，但是改了 <code>a</code>，还是同时影响到 b,c 了。这是因为内建的 clone 是不支援 deep clone (深度复制)。这可能会有很复杂的情况，如果真的要复制，你需要自己写方法。</p>

<p>看起来好像会很复杂，所幸我们不常碰到需要 clone 的情况。</p>

    </div>
  </div></div><div class='frame'><h1>
      9. 作用域 Variable Scope
    </h1><h4>所属章节：编程语言的设计</h4><hr><div class="post group">
    <div class="post-content markdown">
      <p>变量作用域 Variable Scope 指的是变量可以被存取到的范围，一般分成本地变量(Local variable)和全局变量(Global variable)</p>

<figure class="figure-code code"><figcaption><span>
</span></figcaption><div class="highlight"><pre><span class="k">def</span> <span class="nf">foo</span>
 <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">end</span>

<span class="n">x</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">foo</span><span class="p">()</span>

<span class="n">x</span> <span class="c1"># 仍然是 2
</span></pre></div>
</figure>

<p>这段简单的程序中，宣告在方法里面的局部变量 <code>x</code>，只可以在该方法内存取的到，对外面来说是没有影响的。对 Ruby 来说，一个局部变量的 scope 就是在该方法内。</p>

<p>至于全局变量则是不管在程式哪里，都可以存取的到。在 Ruby 之中会用 <script type="math/tex"></script> 开头，例如 <code>$THIS_IS_GLOBAL_VERIABLE</code></p>

<blockquote>
<p>Ruby 还有对象变量(Instance variable) Scope 和类变量(Class variable) scope，之后的面向对象教程会学到。</p>
</blockquote>

<p>设计作用域 Variable Scope 的目的是避免变量名称冲突(naming collisions)。</p>

<p>为什么要避免变量名称冲突呢？一个软件会有很多方法，也会用到很多不是我们自己写的库，如果没有作用域的话，变量名称很可能会刚好命名成一样，就冲突了。</p>

<p>同样的原因，我们也会避免使用全域变量，就算要用，全域变量的命名也会取比较长，来避免冲突。</p>

    </div>
  </div></div><div class='frame'><h1>
      10. 正则表达式 Regular Expression
    </h1><h4>所属章节：编程语言的设计</h4><hr><div class="post group">
    <div class="post-content markdown">
      <p><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式 Regular Expression</a>是一种精巧比对字串的方式。我们在第一集百宝箱中，曾经用过这个技巧来验证 URL 网址：</p>

<p><code>validates_format_of :friendly_id, :with =&gt; /\A[a-z0-9\-]+\z/</code></p>

<p>其中的 <code>/\A[a-z0-9\-]+\z/</code> 就是一个正则表达式，检查字符串必须是小写a到z，或数字0到9，或是横线<code>-</code>。</p>

<p>更多用途举例：</p>

<ul>
<li>检查 “Mississippi” 字串里面有没有出现 “ss” ?</li>
<li>找出每段文章中的第三个单字</li>
<li>将文章”开头”中的 “Dear” 全部用 “Hi” 替换</li>
<li>将文章结尾的”.”换成”。”</li>
<li>检查是否是合法的 Email、URL 自串</li>
</ul>

<p>用法规则：</p>

<ul>
<li>
<code>.</code> 符合任何单一字符</li>
<li>
<code>\w</code> 单字字符</li>
<li>
<code>\d</code> 数字字符</li>
<li>
<code>\s</code> 任何空白</li>
<li>
<code>\S</code> 非空白</li>
<li>
<code>^</code> 行首位置</li>
<li>
<code>*</code> 出现 0 次以上</li>
<li>
<code>+</code> 出现 1 次以上</li>
<li>
<code>?</code> 出现 0 或 1 次</li>
<li>
<code>{m,n}</code> 出现 m 次到 n 次</li>
<li>
<code>[a-z]</code> a 到 z 范围内的任何单一字符</li>
<li>
<code>[^a-z]</code> 非 a-z 之外的任何单一字符</li>
</ul>

<p>线上工具：</p>

<ul>
<li><a href="http://rubular.com/" rel="nofollow" target="_blank">http://rubular.com/</a></li>
<li><a href="https://regex101.com/" rel="nofollow" target="_blank">https://regex101.com/</a></li>
</ul>

<p>所幸，你不需要学习太难的表达式，大部分常用的正规表达式，用抄的就可以了，例如 <a href="http://www.jianshu.com/p/e7bb97218946">知道这20个正则表达式，能让你少写1,000行代码</a>。</p>

    </div>
  </div></div><div class='frame'><h1>
      11. 什么是算法?
    </h1><h4>所属章节：算法和数据结构</h4><hr><div class="post group">
    <div class="post-content markdown">
      <p>1960 年代发明的结构化程式设计 (Structured programming) 是一种编程典范。它采用函式、程式码区块、for循环以及while循环等结构，来取代传统的 <a href="https://zh.wikipedia.org/wiki/Goto">goto</a>语法。希望借此来改善电脑程式的明晰性、品质以及开发时间，并且避免写出面条式代码。程式从可以随便跳来跳去的 goto 写法，变成限制成三种流程控制：循序(prodecure)、分歧(if-else)、反复(while loop)。因此算法也是由这三大基础结构所构成。</p>

<p>现今的编程语言几乎都有这些特性，成为「常识」：流程控制(Flow control)和函数(function)</p>

<p>所谓的<a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95">算法</a>是一种有次序、明确定义和可行，最终会结束、有输出的可执行步骤。虽然你可以用各种方式来描述一个算法，例如画一个流程图也可以是算法，但是对程序员来说，使用结构化形式来描述解决问题的详细步骤，是最常见的方式。</p>

<p>例如，这是一个给数组求最大值的算法，先假设第一个元素最大，然后依序走访数组每一个元素，检查哪一个比较对就指派给 <code>max</code> 变量。最后跑完剩下来的 <code>max</code> 就是最大值。</p>

<figure class="figure-code code"><figcaption><span>
</span></figcaption><div class="highlight"><pre><span class="k">def</span> <span class="nf">find_max</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
  <span class="n">max</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

  <span class="n">arr</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">max</span>
      <span class="n">max</span> <span class="o">=</span> <span class="n">a</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">return</span> <span class="n">max</span>
<span class="k">end</span>

</pre></div>
</figure>

<p>这个算法看起来非常简单，它的基本思维就是<a href="https://zh.wikipedia.org/zh-cn/%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2">暴力搜寻</a>技术，这是非常基本的解决问题方式：把所有可能的解答都计算过一次，然后从里面挑一个最棒的。</p>

    </div>
  </div></div><div class='frame'><h1>
      12. 如何评估算法
    </h1><h4>所属章节：算法和数据结构</h4><hr><div class="post group">
    <div class="post-content markdown">
      <p>一个算法好不好，要怎么评估呢？电脑科学家特别关心当数据越来越多时，一个算法需要耗费多少时间。</p>

<p>我们使用一种叫做 Big-O 的符号来描述算法的复杂度，复杂度可以分成时间复杂度和空间复杂度，前者计算这个算法要花多少步骤，后者则是耗费多少内存空间。通常我们比较关心前者，以下介绍时间复杂度。</p>

<figure class="figure-code code"><figcaption><span>
</span></figcaption><div class="highlight"><pre><span class="k">def</span> <span class="nf">constant</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="mi">1</span>

  <span class="k">return</span> <span class="n">result</span>
<span class="k">end</span>
</pre></div>
</figure>

<p>这个 constant 方法，不管 n 是多少，执行的步骤都是固定的，执行时间都一样，科学者于是称之这个时间复杂度是 O(1)是常数的。</p>

<figure class="figure-code code"><figcaption><span>
</span></figcaption><div class="highlight"><pre><span class="k">def</span> <span class="nf">linear</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="mi">1</span><span class="p">.</span><span class="nf">upto</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
    <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">i</span>
  <span class="k">end</span>

  <span class="k">return</span> <span class="n">sum</span>
<span class="k">end</span>

</pre></div>
</figure>

<p>这个 linear 方法，当 n 越大的时候，里面的循环就得跑越多次，这时间复杂度为 O(n) 是线性的：当 n 成长十倍时，需要的执行时间也是十倍。</p>

<figure class="figure-code code"><figcaption><span>
</span></figcaption><div class="highlight"><pre><span class="k">def</span> <span class="nf">quadratic</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="mi">1</span><span class="p">.</span><span class="nf">upto</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
    <span class="mi">1</span><span class="p">.</span><span class="nf">upto</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">j</span><span class="o">|</span>
      <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">return</span> <span class="n">sum</span>
<span class="k">end</span>

</pre></div>
</figure>

<p>这个 quadratic 方法，当 n 越大的时候，里面的循环就得平方多次，这时间复杂度为 O(n^2) 是平方的：当 n 成长十倍时，需要的执行时间是一百倍。</p>

<figure class="figure-code code"><div class="highlight"><pre>def logarithmic(n)
  result = 0
  while n &gt; 1
    n = n.to_f / 2
    result += 1
  end

  return result
end
</pre></div>
</figure>

<p>这个 logarithmic 方法的 Big-O 是 O(log n)，当 n 成长从 100 变成 100000 时，需要的执行时间是 2.5 倍而已。</p>

<p>以下是不同 Big-O 的成长图表</p>

<p><figure><img src="https://s3-ap-northeast-1.amazonaws.com/ontrackapp-production/luI4sNi3SuajgagMle3S_3.png" title=""></figure></p>

<p>在计算机本科生的算法课程中，会非常详细的去分析和评估算法的复杂度。例如经典的案例就是数组的<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">排序算法</a>。我们在上一堂课中，曾经要求大家练习选择排序法。如果你有练习的话，这个算法内的循环内还有一个循环，这是一个 O(n^2) 的算法。世界上有各式各样的排序算法，在算法课中就会去示范分析每一种算法的优缺点，要多少复杂度。</p>

<p>不同排序算法示范：</p>

<ul>
<li><a href="https://www.toptal.com/developers/sorting-algorithms/">Sorting Algorithms Animations</a></li>
<li><a href="https://www.youtube.com/watch?v=kPRA0W1kECg">15 Sorting Algorithms in 6 Minutes</a></li>
</ul>

<p>其中证明了最好的就是 O(nlogn)，像 Ruby 的 Array#sort 方法就是用<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序法</a>做的。</p>

<p>还有，在编程基础练习中，有一题是在数组中找到最大(或最小)的数字，例如 <code>arr = [5,1,9,4]</code>，以下两种算法都可以得到答案：</p>

<p>第一种：</p>

<figure class="figure-code code"><figcaption><span>
</span></figcaption><div class="highlight"><pre><span class="k">def</span> <span class="nf">find_max</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
  <span class="n">max</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

  <span class="n">arr</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">max</span>
      <span class="n">max</span> <span class="o">=</span> <span class="n">a</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">return</span> <span class="n">max</span>
<span class="k">end</span>

</pre></div>
</figure>

<p>第二种：</p>

<figure class="figure-code code"><figcaption><span>
</span></figcaption><div class="highlight"><pre><span class="k">def</span> <span class="nf">find_max</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
  <span class="n">arr</span><span class="p">.</span><span class="nf">sort</span><span class="p">.</span><span class="nf">last</span>
<span class="k">end</span>
</pre></div>
</figure>

<p>第二种看起来比较简单，但是现在你可以判断第一种方法是 O(n)，第二种确是 O(nlogn) 了，前者比较好。</p>

<blockquote>
<p>当然，Ruby 可以直接调用 <code>arr.max</code> 方法，就得到第一种方法的结果</p>
</blockquote>

    </div>
  </div></div><div class='frame'><h1>
      13. 什么是数据结构?
    </h1><h4>所属章节：算法和数据结构</h4><hr><div class="post group">
    <div class="post-content markdown">
      <p>数据结构定义资料之间的相互关系，是设计算法的载体，数据输入输出和设计算法步骤时，都会对应于使用的数据结构。而不同的数据结构有不同的特性。在计算机本科生的课程中，有门数据结构的课，就是在分析各种不同的数据结构，做不同操作时的优点点和复杂度：<a href="http://bigocheatsheet.com">Common Data Structure Operations</a></p>

<p>对 Ruby 程序员来说，最常用的就是 Array 和 Hash，我们在组合数据类型介绍过 Array 和 Hash 内部原理，现在我们来分析一下常用的操作，对 Array 和 Hash 的算法复杂度。</p>
<h4>插入和删除到容器里面</h4>
<p>要在数组中插入一个值，如果刚好在最后(例如 Arrar#push 方法)，是 O(1)<br>
如果在数组中间插入一个值，因为数组是内存中「连续」的空间，中间新插入，会需要搬动后面所有元素的位置往后移动一格，这是 O(n) 的算法，n 越大需要移动的元素越多。</p>

<p>对散列 Hash 来说，插入是平均复杂度是 O(1)。</p>
<h4>检查一个值都没有在容器里面</h4>
<p>Array 是 O(n)，需要走访整个数组依序检查</p>

<p>Hash 是 O(1)，只要将 key 经过散列算法，就可以直接检查那个位置有没有数据。</p>

<p>让我们动手实验看看，Ruby 内建有 <a href="https://docs.ruby-lang.org/en/2.4.0/Benchmark.html">benchmark</a> 工具，可以让我们量测一个方法的执行时间：</p>

<figure class="figure-code code"><figcaption><span>
</span></figcaption><div class="highlight"><pre><span class="nb">require</span> <span class="s1">'benchmark'</span>

<span class="n">a1</span> <span class="o">=</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">1000000</span><span class="p">){</span> <span class="nb">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 造一个一百万个元素的数组，内容是乱数
</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">a1</span> <span class="o">*</span> <span class="mi">10</span>   <span class="c1"># 数组放大十倍
</span>

<span class="n">h1</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">a1</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">h1</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="ss">:y</span> <span class="p">}</span> <span class="c1"># 把数组转成散列
</span>

<span class="n">h2</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">a2</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">h2</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="ss">:y</span> <span class="p">}</span>


<span class="no">Benchmark</span><span class="p">.</span><span class="nf">bm</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">report</span> <span class="p">{</span>
    <span class="n">a1</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="mi">999</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">report</span> <span class="p">{</span>
    <span class="n">a2</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="mi">999</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">report</span> <span class="p">{</span>
    <span class="n">h1</span><span class="p">[</span><span class="mi">999</span><span class="p">]</span> <span class="o">==</span> <span class="ss">:y</span>
  <span class="p">}</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">report</span> <span class="p">{</span>
    <span class="n">h2</span><span class="p">[</span><span class="mi">999</span><span class="p">]</span> <span class="o">==</span> <span class="ss">:y</span>
  <span class="p">}</span>
<span class="k">end</span>
</pre></div>
</figure>

<p>这个实验检查容器里面有没有 999 这个值，这是结果：</p>

<figure class="figure-code code"><div class="highlight"><pre>   user     system      total        real
   0.000000   0.000000   0.000000 (  0.005854) # 数组一
   0.060000   0.010000   0.070000 (  0.064084) # 十倍大的数组二：时间约成长 10 倍
   0.000000   0.000000   0.000000 (  0.000005) # 散列一:
   0.000000   0.000000   0.000000 (  0.000005) # 十倍大的散列二: 时间一样
</pre></div>
</figure>

<p>你会发现需要的时间，数组需要的时间约增加了十倍，但是散列却一样。</p>

<blockquote>
<p>数据库打索引的原理也是一样的，没有打索引就是 O(n)，有打索引是 O(logn)。当数据库成长到上百万笔资料时，有没有索引的时间差距是很大的。数据库内部用的索引数据结构是 <a href="https://zh.wikipedia.org/zh-cn/B%E6%A0%91">B-tree</a></p>
</blockquote>

    </div>
  </div></div><div class='frame'><h1>
      14. 算法的极限
    </h1><h4>所属章节：算法和数据结构</h4><hr><div class="post group">
    <div class="post-content markdown">
      <p>这一节我们探讨一个有趣的问题，电脑这么厉害，有没有不能计算的问题？</p>

<p>有的，例如<a href="https://zh.wikipedia.org/wiki/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98">停机问题</a>：你没办法写一个软件，去判断另一个软件会不会当机。所以说 Apple 审核不可能审核到你的 App 会不会当机。</p>

<p>另外，有些问题虽然可以计算，但是算法耗费太多资源或时间，这种问题的最佳解 Big-O 是 O(2^N)，而非多项式时间内。因此要求最佳解是不切实际的，只能用最佳化逼近解。</p>

<p>我们可以看看 O(2^N) 有多恐怖，当 N = 100 时，就比大霹雳以来的微秒数还要多。没有电脑可以在我们有生之年可以计算完毕。最近的热门话题 <a href="https://zh.wikipedia.org/wiki/AlphaGo">AlphaGo</a> 下围棋之所以这么了不起，就是因为就算现代电脑这么先进了，也不可能穷举所有的可能来下围棋。</p>

<p>已知最佳解就是 O(2^N) 的算法问题，就叫做 <a href="https://zh.wikipedia.org/wiki/NP_(%E5%A4%8D%E6%9D%82%E5%BA%A6)">NP 类型</a>的算法问题，例如河内塔步骤：假设有 N 个的环，那么最佳解的移动步骤是 2^N - 1，原始版本和尚要移动 64 个环根本就不可能。其他像是西洋棋必胜策略也是 NP 类型问题。</p>

<p>已知有指数时间解，但是不确定有没有更好的多项式时间解，这就作 <a href="https://zh.wikipedia.org/wiki/NP%E5%AE%8C%E5%85%A8">NP-Complete</a> 类型的问题。例如 <a href="https://zh.wikipedia.org/wiki/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%91%98%E9%97%AE%E9%A2%98">旅行推销员问题</a>是 O(n!) n阶层时间。</p>

<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/P/NP%E9%97%AE%E9%A2%98">P = NP</a> 是 在理论信息学中计算复杂度理论领域里至今没有解决的问题。</p>
</blockquote>

    </div>
  </div></div><div class='frame'><h1>
      15. 推荐书籍
    </h1><h4>所属章节：算法和数据结构</h4><hr><div class="post group">
    <div class="post-content markdown">
      <p>这门教程的知识点非常多，包括了计算机大学本科 1. 数据结构 2. 算法 3. 操作系统 4. 编译器 5. 编程语言，大一到大三共五门必修课程的主要概念。我推荐以下的书籍可以继续进修：</p>

<ul>
<li>
<a href="https://book.douban.com/subject/24529132/">改变未来的九大算法</a> 介绍九个影响世界的重要的算法，没有代码，是科普书</li>
<li>
<a href="https://book.douban.com/subject/26937425/">一路编程</a>，入门程度的概括性介绍软件编程</li>
<li>
<a href="https://book.douban.com/subject/25927585/">代码之随</a> 介绍编程语言的设计</li>
<li><a href="https://book.douban.com/subject/26365491/">程序是怎样跑起来的</a></li>
<li><a href="https://book.douban.com/subject/26397183/">计算机是怎样跑起来的</a></li>
<li><a href="https://book.douban.com/subject/6424904/">大话数据结构</a></li>
<li><a href="https://book.douban.com/subject/26979890/">算法图解</a></li>
</ul>

<blockquote>
<p>放心，这些都不是大部头的教科书</p>
</blockquote>
<h3>关于算法和找工作面试</h3>
<p>有些公司很爱考算法题目，特别是大型公司，例如 Google、Microsof、Facebook、BAT 等大企业。因为他们偏好学历好计算机本科系刚毕业，聪明、底子好的学生，不看重作品集，招聘后再内训。</p>

<p>如果你对这类型公司有偏好，你需要熟悉各种数据结构的操作算法，例如 Stack、Queue、Linked List、Tree、Graph 等等。</p>

<p>基本的解题策略是：先很快的用暴力解(Brute-force)，先别担心算法效率。然后再最佳化，找出哪些步骤是多余重复的计算。通常考官都会逐步提示你完成最佳化。</p>

<p>你需要花时间练习熟悉题型：例如</p>

<ul>
<li><a href="http://www.coderbyte.com/" rel="nofollow" target="_blank">http://www.coderbyte.com/</a></li>
<li><a href="https://leetcode.com/" rel="nofollow" target="_blank">https://leetcode.com/</a></li>
<li><a href="https://book.douban.com/subject/25753386/">Cracking the Coding Interview</a></li>
</ul>

<p>就算是大神，碰到这种公司不先刷题也是被拒的。</p>

<ul>
<li><a href="https://twitter.com/mxcl/status/608682016205344768" rel="nofollow" target="_blank">https://twitter.com/mxcl/status/608682016205344768</a></li>
<li><a href="http://osherove.com/blog/2011/4/5/my-google-rejection-letter.html" rel="nofollow" target="_blank">http://osherove.com/blog/2011/4/5/my-google-rejection-letter.html</a></li>
</ul>

    </div>
  </div></div><div class='end'>
              <a href='https://fullstack.qzy.camp/'>
                <img src='https://img.buzzfeed.com/buzzfeed-static/static/2014-10/26/6/enhanced/webdr08/longform-original-14836-1414320930-10.jpg'>
              </a>
              <p>The End</p>
            </div>